{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/char.js","webpack:///./src/scripts/monster.js","webpack:///./src/scripts/game.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","playerImg","Image","src","char","document","getElementById","getContext","octopusIMG","octopusATK","vampireIMG","vampireATK","werewolfIMG","werewolfATK","reaperIMG","reaperATK","Monster","type","x","y","this","currentHP","maxHP","monsterIMG","monsterATK","dmg","drops","attackX","attackY","moved","charX","charY","Math","abs","rng","num","floor","random","goldBar","wall","door","floorBGColor","healthPotion","manaPotion","sword","showInvCursor","invCursorX","maxWidth","invCursorY","invCursorPos","items","monsters","newRoom","monsterNum","log","maxHeight","monsterType","goldCount","inventory","currentMP","showAttack","attackBlock","monstersMove","gameOver","showControls","gameCanvas","togglePause","moveChar","dx","dy","window","monsterBlock","values","forEach","row","monster","beginPath","globalAlpha","fillStyle","rect","fill","font","fillText","closePath","newX","newY","movedRoom","monsterTurn","takeTurn","dxMon","dyMon","dxMonNorm","dyMonNorm","newMonX","newMonY","canMoveX","canMoveY","undefined","tempMon","clearRect","j","drawImage","keys","itemName","length","push","slice","concat","console","cD","invHeight","strokeStyle","stroke","hpYCoord","toggleAttack","bool","useInvCursor","paused","canvas","width","height","setTimeout","addEventListener","e","preventDefault","newCursorX","newCursorY","invXCoord","invYCoord","moveInvCursor","useItem","attackDir","takeDmg","randomNum","err","attack"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import {floorBGColor} from \"./game\";\n\n\nvar playerImg = new Image();\nplayerImg.src = \"https://image.flaticon.com/icons/svg/2328/2328493.svg\";\n\nexport let cD = 50; // character dimension\n// Players starting position\nexport const startX = 9;\nexport const startY = 5;\n\nlet x = cD * startX;\nlet y = cD * startY;\n\n\nconst canvas = document.getElementById(\"gameCanvas\");\nconst char = canvas.getContext(\"2d\");\n\nexport function renderChar(newX, newY) {\n    char.beginPath();\n    char.fillStyle = floorBGColor;\n    // char.rect(x * cD, y * cD, cD, cD);\n    // char.rect(newX * cD, newY * cD, cD, cD);\n    char.fill();\n    char.drawImage(playerImg, newX * cD, newY * cD, cD, cD);\n\n\n    x = newX;\n    y = newY;\n    char.closePath(); \n}","\nvar octopusIMG = new Image();\noctopusIMG.src = \"https://image.flaticon.com/icons/svg/2196/2196893.svg\";\n\nvar octopusATK = new Image();\noctopusATK.src = \"https://image.flaticon.com/icons/svg/651/651510.svg\";\n\nvar vampireIMG = new Image();\nvampireIMG.src = \"https://image.flaticon.com/icons/svg/2286/2286964.svg\";\n\nvar vampireATK = new Image();\nvampireATK.src = \"https://image.flaticon.com/icons/svg/209/209853.svg\";\n\nvar werewolfIMG = new Image();\nwerewolfIMG.src = \"https://image.flaticon.com/icons/svg/2534/2534552.svg\";\n\nvar werewolfATK = new Image();\nwerewolfATK.src = \"https://image.flaticon.com/icons/svg/2068/2068587.svg\";\n\nvar reaperIMG = new Image();\nreaperIMG.src = \"https://image.flaticon.com/icons/svg/2624/2624475.svg\";\n\nvar reaperATK = new Image();\nreaperATK.src = \"https://image.flaticon.com/icons/svg/2674/2674440.svg\";\n\nexport class Monster{\n    constructor(type, x, y){\n        switch(type){\n            case \"o\":\n                this.name = \"Octopus\";\n                this.currentHP = 100;\n                this.maxHP = 100;\n                this.monsterIMG = octopusIMG;\n                this.monsterATK = octopusATK;\n                this.dmg = 10;\n                this.drops = [\"HP\", \"G\"]\n                break;\n            case \"w\":\n                this.name = \"Werewolf\";\n                this.currentHP = 150;\n                this.maxHP = 150;\n                this.monsterIMG = werewolfIMG;\n                this.monsterATK = werewolfATK;\n                this.dmg = 20;\n                this.drops = [\"HP\", \"G\", \"ATK\"]\n                break;\n            case \"v\":\n                this.name = \"Vampire\";\n                this.currentHP = 200;\n                this.maxHP = 200;\n                this.monsterIMG = vampireIMG;\n                this.monsterATK = vampireATK;\n                this.dmg = 50;\n                break;\n            case \"r\":\n                this.name = \"Reaper\";\n                this.currentHP = 1000;\n                this.maxHP = 1000;\n                this.monsterIMG = reaperIMG;\n                this.monsterATK = reaperATK;\n                this.dmg = 90;\n                break;\n            default:\n                this.name = \"Unknown\";\n                this.currentHP = 1;\n                this.maxHP = 1;\n                this.monsterIMG = octopusIMG;\n                this.monsterATK = octopusATK;\n                this.dmg = 1;\n        }\n        this.x = x;\n        this.y = y;\n        this.attackX = null;\n        this.attackY = null;\n        this.moved = false;\n    }\n\n    takeDmg(dmg){\n        this.currentHP -= dmg;\n        return this.currentHP;\n    }\n\n    takeTurn(charX, charY){\n        if(this.attackX !== null){\n            // Attacking the character this turn\n            return true // return true for attacking\n        } else {\n            if ((charX === this.x && Math.abs(charY-this.y) === 1) || (charY === this.y && Math.abs(charX - this.x) === 1)){\n                this.attackX = charX;\n                this.attackY = charY;\n                return null;\n            }\n            //Move the monster towards the player\n            return false // return false for not attacking\n        }\n        \n    }\n}\n","import { cD, renderChar, startX, startY } from \"./char\";\nimport { Monster} from \"./monster\";\n\n// Random Number Generator\nconst rng = (num) => Math.floor(Math.random() * num)+1;\n//Images\nvar goldBar = new Image();\ngoldBar.src = \"https://image.flaticon.com/icons/svg/362/362944.svg\";\n\nvar wall = new Image();\nwall.src = \"https://image.flaticon.com/icons/svg/351/351764.svg\";\n\nvar door = new Image();\ndoor.src = \"https://www.flaticon.com/premium-icon/icons/svg/2401/2401054.svg\";\n\nexport const floorBGColor = \"#999\";\n\nvar healthPotion = new Image();\nhealthPotion.src = \"https://image.flaticon.com/icons/svg/506/506927.svg\";\n\nvar manaPotion = new Image();\nmanaPotion.src = \"https://image.flaticon.com/icons/svg/1006/1006951.svg\";\n\nvar sword = new Image();\nsword.src = \"https://image.flaticon.com/icons/svg/361/361806.svg\";\n// width and height of dungeons\nexport const maxWidth = 19;\nexport const maxHeight = 11;\n// Inventory Coords\nconst invXCoord = maxWidth * cD + 22;\nconst invYCoord = 90;\nconst invWidth = 5;\nconst invHeight = 5;\n// Inventory Cursor\nlet showInvCursor = false;\nlet invCursorX = maxWidth * cD + 22;\nlet invCursorY = 90;\nlet invCursorPos = 0;\n// Char Pos\nconst char = [startX, startY];\n// HP Bar\nconst hpXCoord = maxWidth * cD + 22;\nconst hpYCoord = 45;\nconst hpHeight = 15\n// TODO: Implement rooms object when ready\n// let rooms = {}; // 9 * 9 room. player starts in [5][5]\n// for(let i = 0; i < 10; i++){\n//      rooms[i] = {};\n// }\n// let currentRoom = [5,5];\n// Items in the room\nlet items = {};\nlet monsters = {};\n\nconst newRoom = () => { // Generate a new room\n    monsters = {};\n    items = {\n        \"G\":[],\n        \"HP\":[],\n        \"MP\":[]\n    };\n    for (let i = 1; i < maxWidth-1; i++) {\n        monsters[i] = {};\n    }\n    // Monster generator\n    // let monsterNum = Math.floor((rng(100)-(100-monsterLimit*10)+9)/10);\n    let monsterNum = Math.floor(Math.log(rng(34)-10));\n    for(let i = 0; i < monsterNum; i++){\n        let x = char[0];\n        let y = char[1];\n        while(char[0] === x && char[1] === y) {\n            x = rng(maxWidth - 2);\n            y = rng(maxHeight - 2);\n        }\n        const monsterType = rng(100);\n        if (monsterType > 98) {\n            monsters[x][y] = new Monster(\"r\", x, y)\n        } else if (monsterType > 80) {\n            monsters[x][y] = new Monster(\"v\", x, y)\n        } else if (monsterType > 50) {\n            monsters[x][y] = new Monster(\"w\", x, y)\n        } else{\n            monsters[x][y] = new Monster(\"o\", x, y)\n        }\n    }\n}\nnewRoom(); // Generate the room in the beginning of the game\nitems = { // Initial Room has items for player\n    \"G\": [[17, 1], [17, 2]],\n    \"HP\": [[16, 2], [16, 3]],\n    \"MP\": [],\n};\n// Some Health Potions\nlet goldCount = 0;\nlet inventory = [\"HP\",  \"MP\"];\nlet currentHP = 20;\nlet maxHP = 100;\nlet currentMP = 50;\nlet maxMP = 100;\nlet userATK = 50;\nlet showAttack = false; // When you prep an attack, it'll show your attack range\nlet attackBlock = [null,null]; // the attack coords of your character\nlet monstersMove = false; // Tells you when the monsters should move\nlet gameOver = false; \nlet showControls = false;\n// TODO: might have to change to dx, dy in the future when implementing different weapons \n// Drawing Board\nconst canvas = document.getElementById(\"gameCanvas\"); // The actual canvas element\nconst gameCanvas = canvas.getContext(\"2d\"); // The paintbrush to draw everything required for this game\nexport const togglePause = () =>{\n    showControls = !showControls;\n    moveChar(0,0);\n}\n// This is used to move the character. moveChar(0,0) is usually used to re-render the game\nexport const moveChar = (dx, dy) => {\n    window.items = items;\n    if (char[0] < 0){return;} // The character has died\n    // Check to see if character is out of bounds\n    if(char[0] + dx === 0 || char[0] + dx === maxWidth-1){\n        if (char[1] !== (maxHeight - 1) / 2) {return;}\n    }\n    if(char[1] + dy === 0 || char[1] + dy === maxHeight-1){\n        if (char[0] !== (maxWidth - 1) / 2)  {return;}\n    }\n    // Check to see if monster is blocking the characters movement\n    let monsterBlock = false; \n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n            if (monster.x === char[0] + dx && monster.y === char[1] + dy) {\n                monsterBlock = true; // Character is blocked from moving here\n            }\n        })\n    })\n    // If not blocked by monster, continue the action\n    if(!monsterBlock && !showControls){\n        char[0] += dx;\n        char[1] += dy;\n        let movedRoom = false;\n        // Check to see if the player went through a door\n        // TODO: Make sure to only render doors that are valid (right now it's infinite dungeon)\n        if(char[1] === (maxHeight-1)/2){\n            if (char[0] === 0) {\n                char[0] = maxWidth - 2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[0] === maxWidth-1) {\n                char[0] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        } else if(char[0] === (maxWidth-1)/2){\n            if(char[1] === 0){\n                char[1] = maxHeight-2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[1] === maxHeight-1){\n                char[1] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        }\n        // if the player moved (but not to another room) and the monsters are allowed to move\n        // then the monsters will take their turn\n        if ((dx + dy !== 0 || monstersMove) && !movedRoom) {\n            monstersMove = false;\n            Object.values(monsters).forEach(row => {\n                Object.values(row).forEach(monster => {\n                    if (monster.moved) { return; } // if the monster already moved this turn,\n                    const monsterTurn = monster.takeTurn(char[0], char[1]);\n                    if (monsterTurn) { // If this returns true, the monster will be attacking a position\n                        if (monster.attackX === char[0] && monster.attackY === char[1]) {\n                            // If player is in the attack range, lose health\n                            currentHP -= monster.dmg;\n                        }\n                        // Attack has completed. Now set it to null\n                        monster.attackX = null;\n                        monster.attackY = null;\n                    } else if (monsterTurn === false) { // Not close enough to attack the player\n                        // Difference between char and monster\n                        const dxMon = char[0] - monster.x;\n                        const dyMon = char[1] - monster.y;\n                        // A step towards the player\n                        const dxMonNorm = Math.abs(dxMon) / dxMon || 0;\n                        const dyMonNorm = Math.abs(dyMon) / dyMon || 0;\n                        // New Pos if they move\n                        const newMonX = monster.x + dxMonNorm;\n                        const newMonY = monster.y + dyMonNorm;\n                        // can move in that direction\n                        let canMoveX = true;\n                        let canMoveY = true;\n                        // Check if monsters are blocking\n                        if (monsters[monster.x][newMonY] !== undefined) {\n                            canMoveY = false;\n                        }\n                        if (monsters[newMonX][monster.y] !== undefined) {\n                            canMoveX = false;\n                        }\n                        // Temporarily save the monster, delete the monster from monsters object\n                        // Then move the monster and save it in the new coords\n                        const tempMon = monster;\n                        delete monsters[monster.x][monster.y]\n                        if (rng(100) < 50) {\n                            if (canMoveY) {\n                                tempMon.y = newMonY;\n                            } else if(canMoveX){\n                                tempMon.x = newMonX;\n                            }\n                        } else {\n                            if (canMoveX) {\n                                tempMon.x = newMonX;\n                            } else if (canMoveY) {\n                                tempMon.y = newMonY;\n                            }\n                        }\n                        tempMon.moved = true;\n                        monsters[tempMon.x][tempMon.y] = tempMon;\n                    }\n                })\n            })\n        }\n        // once all the monsters have moved, we will set it back to false for next turn\n        Object.values(monsters).forEach(row => {\n            Object.values(row).forEach(monster => {\n                monster.moved = false; \n            })\n        })\n        // If currentHP <= 0, we set gameOver to true so we player can't do anything\n        if (currentHP <= 0) {\n            currentHP = 0;\n            char[0] = -1000;\n            char[1] = -1000;\n            gameOver = true;\n        }\n    } else if(showControls){\n        gameCanvas.beginPath();\n        gameCanvas.globalAlpha = 0.5;\n        gameCanvas.fillStyle = \"#555\";\n        gameCanvas.rect(100, 100, (maxWidth-4)*cD, (maxHeight-4)*cD);\n        gameCanvas.fill();\n        gameCanvas.font = \"30px Roboto, sans serif\"\n        gameCanvas.fillStyle = \"#FFF\";\n        gameCanvas.fillText(\"Arrow keys = Movement\", 110, 160)\n        gameCanvas.fillText(\"Spacebar = Use Item/Start Attack\", 110, 210)\n        gameCanvas.fillText(\"Z = Inventory\", 110, 270)\n        gameCanvas.fillText(\"Spacebar (After Starting Attack) = Attack/Wait\", 110, 330)\n        gameCanvas.font = \"15px Roboto, sans serif\"\n        gameCanvas.fillText(\"Waiting occurs when you hit an empty area\", 500, 350)\n        gameCanvas.font = \"30px Roboto, sans serif\"\n        gameCanvas.fillText(\"Esc = Show/Hide Controls\", 110, 430)\n        gameCanvas.globalAlpha = 1;\n        gameCanvas.closePath()\n        return;\n    } else {return;} // if character is blocked by the monster, don't move here\n    // Drawing Floor, Walls, Items, and Monsters\n    gameCanvas.beginPath();\n    if(showInvCursor || gameOver){\n        gameCanvas.globalAlpha = 0.5;\n    }\n    gameCanvas.clearRect(0, 0, maxWidth * cD, maxHeight * cD);\n    gameCanvas.closePath();\n    for(let i = 1; i < maxWidth-1; i++){\n        for(let j = 1; j < maxHeight-1; j++){\n            //Dungeon Floor\n            gameCanvas.beginPath();\n            gameCanvas.rect(i * cD, j * cD, cD, cD);\n            gameCanvas.fillStyle = floorBGColor;\n            gameCanvas.fill();\n            gameCanvas.closePath();\n        }\n    }\n    gameCanvas.beginPath();\n    // Drawing the walls\n    for (let i = 0; i < maxWidth; i++) {\n        if (i === 0 || i === maxWidth - 1) {\n            for (let j = 0; j <= maxHeight; j++) {\n                if (j === (maxHeight - 1) / 2) {\n                    gameCanvas.drawImage(door, i*cD, j*cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n            continue;\n        }\n        for (let j = 0; j < maxHeight; j++) {\n            if (j === 0 || j === maxHeight - 1) {\n                if (i === (maxWidth - 1) / 2) {\n                    gameCanvas.drawImage(door, i * cD, j * cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n        }\n    }\n    // Drawing Items\n    Object.keys(items).forEach(itemName =>{\n        for(let i = 0; i < items[itemName].length; i++){\n            // If character is standing on the item, push it to their inventory\n            const x = items[itemName][i][0];\n            const y = items[itemName][i][1];\n            if ( x === char[0] && y === char[1]){\n                \n                if(itemName === \"G\"){goldCount++;}\n                else { inventory.push(itemName);}\n\n                items[itemName] = items[itemName].slice(0, i).concat(items[itemName].slice(i + 1, items.length));\n                i--;\n            } else {\n                switch(itemName){\n                    case \"G\":\n                        gameCanvas.drawImage(goldBar, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"HP\":\n                        gameCanvas.drawImage(healthPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"MP\":\n                        gameCanvas.drawImage(manaPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    default:\n                        console.log(`Unknown Item: ${itemName}`)\n                        break;\n                }\n            }\n        }\n    })\n    // for (let i = 0; i < maxWidth; i++) {\n    //     for (let j = 0; j < maxHeight; j++) {\n    //         let renderGold = false;\n    //         let renderHP = false;\n    //         let renderMP = false;\n    //         // render Walls.\n    //         // iterate through items\n    //         // for(let k = 0; k < wC[i][j].length; k++){\n    //         //     switch (wC[i][j][k]) {\n    //         //         case \"w\":\n    //         //             // gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n    //         //             renderWall = true;\n    //         //             break;\n    //         //         case \"d\":\n    //         //             renderDoor = true;\n    //         //             break;\n    //         //         case \"G\":\n    //         //             // gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD);\n    //         //             renderGold = true;\n    //         //             break;\n    //         //         case \"HP\":\n    //         //             // gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD);\n    //         //             renderHP = true;\n    //         //             break;\n    //         //         case \"MP\":\n    //         //             // gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD);\n    //         //             renderMP = true;\n    //         //             break;\n    //         //         default:\n    //         //             break;\n    //         //     }\n    //         // }\n    //         if (renderGold) { gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD); }\n    //         if (renderHP) { gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD); }\n    //         if (renderMP) { gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD); }\n    //     }\n    // }\n    // Render the character\n    renderChar(char[0], char[1]);\n    // Render Monsters\n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n        // const monster = monsters[i][j];\n            gameCanvas.drawImage(monster.monsterIMG, monster.x * cD, monster.y * cD, cD, cD);\n            // If monsters have less health than max health, render it\n            if (monster.currentHP < monster.maxHP) { \n                gameCanvas.fillStyle = \"#FFF\";\n                gameCanvas.rect(monster.x*cD, monster.y*cD, cD, 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n                gameCanvas.fillStyle = \"#F00\";\n                gameCanvas.rect(monster.x * cD, monster.y * cD, cD * (monster.currentHP / monster.maxHP), 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n            }\n            // if monster is attacking, show direction\n            if (monster.attackX !== null) { \n                gameCanvas.globalAlpha = 0.5;\n                gameCanvas.drawImage(monster.monsterATK, monster.attackX * cD, monster.attackY * cD, cD, cD);\n                gameCanvas.globalAlpha = 1;\n            }\n        })\n    })\n    gameCanvas.closePath();\n    if(showAttack === true){ // Show your attack range\n        gameCanvas.beginPath();\n        gameCanvas.globalAlpha = 0.8;\n        gameCanvas.drawImage(sword, attackBlock[0]*cD, attackBlock[1]*cD, cD, cD)\n        gameCanvas.globalAlpha = 1;\n        gameCanvas.closePath();\n    }\n\n    if (showInvCursor || gameOver) {\n        gameCanvas.globalAlpha = 1;\n    }\n    // Inventory UI\n    gameCanvas.beginPath();\n    gameCanvas.rect(maxWidth * cD, 0, 300, (maxHeight*cD));\n    gameCanvas.fillStyle = \"#666666\"\n    gameCanvas.fill();\n    gameCanvas.rect(invXCoord, invYCoord, cD*invWidth, (invHeight * cD))\n    gameCanvas.strokeStyle = \"#FFF\";\n    gameCanvas.stroke();\n    for(let i = 0; i < inventory.length;i++){\n        switch(inventory[i]){\n            case \"HP\":\n                gameCanvas.drawImage(healthPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            case \"MP\":\n                gameCanvas.drawImage(manaPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            default:\n                break;\n        }\n    }\n    gameCanvas.closePath();\n    // HP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current HP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, (cD*5 * currentHP/maxHP), hpHeight);\n    gameCanvas.fillStyle = \"#F00\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // MP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current MP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, (cD*5 * currentMP/maxMP), hpHeight);\n    gameCanvas.fillStyle = \"#00F\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Inventory Cursor\n    if (showInvCursor) {\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#000\";\n        gameCanvas.fillText(\"INVENTORY\", (maxWidth * cD / 2)-cD*4, maxHeight * cD / 2);\n        gameCanvas.rect(invCursorX, invCursorY, cD, cD);\n        gameCanvas.strokeStyle = \"#FFF\";\n        gameCanvas.stroke();\n        gameCanvas.closePath();\n    }\n\n    // Gold Counter\n    gameCanvas.beginPath();\n    gameCanvas.drawImage(goldBar, maxWidth*cD+20, 0, cD, cD);\n    gameCanvas.font = \"15px Roboto, sans serif\";\n    gameCanvas.fillStyle = \"#ffd700\"\n    gameCanvas.fillText(`x ${goldCount}`, maxWidth * 50 + 80, 30, 225);\n    gameCanvas.closePath();\n    if(gameOver){ // If player died\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#ff0000\";\n        gameCanvas.fillText(\"GAME OVER\", (maxWidth * cD / 2) - cD * 4, maxHeight * cD / 2 + 25);\n        gameCanvas.closePath();\n    }\n    return;\n}\n\nexport const toggleInvCursor = bool => {\n    showInvCursor = bool;\n    moveChar(0,0);\n}\n\nexport const moveInvCursor = (dx, dy) => {\n    const newCursorX = invCursorX + dx * cD;\n    const newCursorY = invCursorY + dy * cD;\n    if(newCursorX >= invXCoord && newCursorX < invXCoord + (invWidth * cD)){\n        invCursorX = newCursorX;\n        invCursorPos += dx\n    }\n    if (newCursorY >= invYCoord && newCursorY < invYCoord +(invHeight * cD)) {\n        invCursorY = newCursorY;\n        invCursorPos += (dy*5)\n    }\n    moveChar(0,0);\n}\n\nexport const useItem = () => {\n    if (inventory.length < invCursorPos + 1) {\n        gameCanvas.beginPath();\n        gameCanvas.font = \"10px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Empty Slot\", char[0] * cD, char[1] * cD);\n        gameCanvas.closePath();\n    } else {\n        // Use Item\n        switch (inventory[invCursorPos]) {\n            case \"HP\":\n                currentHP += 25;\n                break;\n            case \"MP\":\n                // Mana\n                currentMP += 50;\n                break;\n            default:\n                break;\n        }\n        if (currentHP > maxHP) {\n            currentHP = maxHP;\n        }\n        if (currentMP > maxMP){\n            currentMP = maxMP;\n        }\n        inventory = inventory.slice(0, invCursorPos).concat(inventory.slice(invCursorPos + 1, inventory.length));\n        moveChar(0,0);\n    }\n}\n\nexport const toggleAttack = (bool=false) =>{\n    showAttack = bool || !showAttack;\n    attackBlock[0] = char[0];\n    attackBlock[1] = char[1]+1;\n    moveChar(0, 0);\n}\n\nexport const attackDir = (dx, dy) => {\n    attackBlock[0] = char[0] + dx;\n    attackBlock[1] = char[1] + dy;\n    moveChar(0,0);\n}\n\nexport const attack = () => {\n    monstersMove = true;\n    try{\n        const newHP = monsters[attackBlock[0]][attackBlock[1]].takeDmg(userATK);\n        if (newHP <= 0) {\n            delete monsters[attackBlock[0]][attackBlock[1]];\n            const randomNum = rng(100);\n            if(randomNum > 99){\n                items[\"MP\"].push([attackBlock[0], attackBlock[1]]);\n            } else if(randomNum > 60){\n                items[\"HP\"].push([attackBlock[0], attackBlock[1]]);\n            } else {\n                items[\"G\"].push([attackBlock[0], attackBlock[1]]);\n            }\n        }\n        toggleAttack();\n    } catch (err) {\n        console.log(err);\n        toggleAttack();\n        gameCanvas.beginPath();\n        gameCanvas.font = \"8px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Waited a turn\", char[0]*cD, char[1]*cD);\n        gameCanvas.closePath();\n    }\n    \n}\n","import \"./styles/index.scss\";\nimport { maxHeight, maxWidth, moveChar, useItem, moveInvCursor, toggleAttack, attack, attackDir, toggleInvCursor, togglePause } from \"./scripts/game\"; \nimport { cD } from \"./scripts/char\";\n\nlet useInvCursor = false;\nlet showAttack = false;\nlet paused = true;\n\nconst keydownPress = e => {\n    if(e.key === \" \"){e.preventDefault();}\n    let dx = 0;\n    let dy = 0;\n    // Movement\n    if (e.key == \"Right\" || e.key == \"ArrowRight\") {\n        dx += 1;\n    } else if (e.key == \"Left\" || e.key == \"ArrowLeft\") {\n        dx -= 1;\n    } else if (e.key == \"Up\" || e.key == \"ArrowUp\") {\n        e.preventDefault();\n        dy -= 1\n    } else if (e.key == \"Down\" || e.key == \"ArrowDown\") {\n        e.preventDefault();\n        dy += 1\n    }\n    if ((e.key === \"z\" || e.key === \"Z\") && !paused) {\n        // Open Inventory\n        useInvCursor = !useInvCursor;\n        toggleInvCursor(useInvCursor);\n    } else if((e.key === \"x\" || e.key === \"X\") && showAttack && !paused) {\n        // Cancel Attack\n        toggleAttack(false);\n        showAttack = false;\n    } else if(e.key === \"Escape\"){\n        paused = !paused;\n        togglePause();\n    } else if(dx+dy != 0 && !useInvCursor && !showAttack && !paused){\n        // if the character has moved and we're not moving the inventory cursor and we're not attacking\n        moveChar(dx, dy);\n    } else if (dx+dy != 0 && useInvCursor && !paused){ \n        // useInvCursor === true => move the inventory cursor\n        moveInvCursor(dx, dy);\n    } else if (e.key === \" \" && useInvCursor && !paused){ \n        // Use Item in inventory\n        useItem();\n    } else if(dx+dy != 0 && showAttack && !paused){\n        attackDir(dx, dy);\n    } else if (e.key === \" \" && !useInvCursor && !paused){\n        // Attack\n        if(showAttack){\n            attack();\n        } else {\n            toggleAttack(true);\n        }\n        showAttack = !showAttack\n    }\n}\n\nconst canvas = document.getElementById(\"gameCanvas\");\n// canvas.width = window.innerWidth - 10;\n// canvas.height = window.innerHeight - 20;\n// Set the width and height of canvas\ncanvas.width = maxWidth * cD + 300;\ncanvas.height = maxHeight * cD;\n// moveChar renders the character without moving it\nsetTimeout(() => {\n    moveChar(0, 0)\n    togglePause();\n}, 100)\nconsole.log(\"Game Loaded\");\n// This will allow us to move the character\ndocument.addEventListener(\"keydown\", keydownPress, false);\n"],"sourceRoot":""}