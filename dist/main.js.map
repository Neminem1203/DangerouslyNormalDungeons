{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/char.js","webpack:///./src/scripts/monster.js","webpack:///./src/scripts/game.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","playerImg","Image","src","char","document","getElementById","getContext","octopusIMG","octopusATK","Monster","type","x","y","this","currentHP","maxHP","monsterIMG","monsterATK","attackX","attackY","moved","dmg","charX","charY","Math","abs","rng","num","floor","random","goldBar","wall","door","floorTile","floorBGColor","healthPotion","manaPotion","sword","showInvCursor","invCursorX","maxWidth","invCursorY","invCursorPos","items","monsters","newRoom","monsterNum","log","maxHeight","goldCount","inventory","currentMP","showAttack","attackBlock","monstersMove","gameOver","showControls","gameCanvas","togglePause","moveChar","dx","dy","window","monsterBlock","values","forEach","row","monster","beginPath","fillStyle","rect","fill","font","fillText","closePath","newX","newY","movedRoom","monsterTurn","takeTurn","dxMon","dyMon","dxMonNorm","dyMonNorm","newMonX","newMonY","canMoveX","canMoveY","undefined","tempMon","globalAlpha","clearRect","j","drawImage","keys","itemName","length","push","slice","concat","console","cD","invHeight","strokeStyle","stroke","hpYCoord","toggleAttack","bool","useInvCursor","paused","keydownPress","e","preventDefault","newCursorX","newCursorY","invXCoord","invYCoord","moveInvCursor","useItem","attackDir","takeDmg","randomNum","err","attack","addEventListener","canvas","width","height","setTimeout"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import {floorTile, floorBGColor} from \"./game\";\n\n\nvar playerImg = new Image();\nplayerImg.src = \"https://image.flaticon.com/icons/svg/2328/2328493.svg\";\n\nexport let cD = 50; // character dimension\n// Players starting position\nexport const startX = 9;\nexport const startY = 5;\n\nlet x = cD * startX;\nlet y = cD * startY;\n\n\nconst canvas = document.getElementById(\"gameCanvas\");\nconst char = canvas.getContext(\"2d\");\n\nexport function renderChar(newX, newY) {\n    char.beginPath();\n    char.fillStyle = floorBGColor;\n    // char.rect(x * cD, y * cD, cD, cD);\n    // char.rect(newX * cD, newY * cD, cD, cD);\n    char.fill();\n    // char.drawImage(floorTile, x*cD, y*cD, cD, cD)\n    // char.drawImage(floorTile, newX*cD, newY*cD, cD, cD)\n    char.drawImage(playerImg, newX * cD, newY * cD, cD, cD);\n\n\n    x = newX;\n    y = newY;\n    char.closePath(); \n}","\nvar octopusIMG = new Image();\noctopusIMG.src = \"https://image.flaticon.com/icons/svg/2196/2196893.svg\";\n\nvar octopusATK = new Image();\noctopusATK.src = \"https://image.flaticon.com/icons/svg/651/651510.svg\";\n\nexport class Monster{\n    constructor(type, x, y){\n        switch(type){\n            case \"o\":\n                this.name = \"Octopus\";\n                this.currentHP = 100;\n                this.maxHP = 100;\n                this.monsterIMG = octopusIMG;\n                this.monsterATK = octopusATK;\n                break;\n            case \"v\":\n                this.name = \"Vampire\";\n                this.currentHP = 200;\n                this.maxHP = 200;\n            default:\n                this.name = \"Unknown\";\n                this.currentHP = 1;\n                this.maxHP = 1;\n        }\n        this.x = x;\n        this.y = y;\n        this.attackX = null;\n        this.attackY = null;\n        this.moved = false;\n    }\n\n    takeDmg(dmg){\n        this.currentHP -= dmg;\n        return this.currentHP;\n    }\n\n    takeTurn(charX, charY){\n        if(this.attackX !== null){\n            // Attacking the character this turn\n            return true // return true for attacking\n        } else {\n            if ((charX === this.x && Math.abs(charY-this.y) === 1) || (charY === this.y && Math.abs(charX - this.x) === 1)){\n                this.attackX = charX;\n                this.attackY = charY;\n                return null;\n            }\n            //Move the monster towards the player\n            return false // return false for not attacking\n        }\n        \n    }\n}\n","import { cD, renderChar, startX, startY } from \"./char\";\nimport { Monster} from \"./monster\";\n\n// Random Number Generator\nconst rng = (num) => Math.floor(Math.random() * num)+1;\n//Images\nvar goldBar = new Image();\ngoldBar.src = \"https://image.flaticon.com/icons/svg/362/362944.svg\";\nvar wall = new Image();\nwall.src = \"https://image.flaticon.com/icons/svg/351/351764.svg\";\nvar door = new Image();\ndoor.src = \"https://www.flaticon.com/premium-icon/icons/svg/2401/2401054.svg\";\nexport var floorTile = new Image();\n// floorTile.src = \"https://image.flaticon.com/icons/svg/1192/1192637.svg\"; // COLORED\n// floorTile.src = \"https://image.flaticon.com/icons/svg/1193/1193200.svg\"; // BLACK ON WHITE\n// floorTile.src = \"https://image.flaticon.com/icons/svg/1192/1192587.svg\"; // WHITE ON BLACK\nexport const floorBGColor = \"#999\";\nvar healthPotion = new Image();\nhealthPotion.src = \"https://image.flaticon.com/icons/svg/506/506927.svg\";\nvar manaPotion = new Image();\nmanaPotion.src = \"https://image.flaticon.com/icons/svg/1006/1006951.svg\";\nvar sword = new Image();\nsword.src = \"https://image.flaticon.com/icons/svg/361/361806.svg\";\n// width and height of dungeons\nexport const maxWidth = 19;\nexport const maxHeight = 11;\n// Inventory Coords\nconst invXCoord = maxWidth * cD + 22;\nconst invYCoord = 90;\nconst invWidth = 5;\nconst invHeight = 5;\n// Inventory Cursor\nlet showInvCursor = false;\nlet invCursorX = maxWidth * cD + 22;\nlet invCursorY = 90;\nlet invCursorPos = 0;\n// Char Pos\nconst char = [startX, startY];\n// HP Bar\nconst hpXCoord = maxWidth * cD + 22;\nconst hpYCoord = 45;\nconst hpHeight = 15\n// TODO: Implement rooms object when ready\n// let rooms = {}; // 9 * 9 room. player starts in [5][5]\n// for(let i = 0; i < 10; i++){\n//      rooms[i] = {};\n// }\n// let currentRoom = [5,5];\n// Items in the room\nlet items = {};\nlet monsters = {};\n\nconst newRoom = () => { // Generate a new room\n    monsters = {};\n    items = {\n        \"G\":[],\n        \"HP\":[],\n        \"MP\":[]\n    };\n    for (let i = 1; i < maxWidth-1; i++) {\n        monsters[i] = {};\n    }\n    // Monster generator\n    // let monsterNum = Math.floor((rng(100)-(100-monsterLimit*10)+9)/10);\n    let monsterNum = Math.floor(Math.log(rng(34)-10));\n    for(let i = 0; i < monsterNum; i++){\n        let x = char[0];\n        let y = char[1];\n        while(char[0] === x && char[1] === y) {\n            x = rng(maxWidth - 2);\n            y = rng(maxHeight - 2);\n        }\n        monsters[x][y] = new Monster(\"o\", x, y)\n    }\n}\nnewRoom(); // Generate the room in the beginning of the game\nitems = { // Initial Room has items for player\n    \"G\": [[1, 1], [1, 2]],\n    \"HP\": [[2, 2], [2, 3]],\n    \"MP\": [],\n};\n// Some Health Potions\nlet goldCount = 0;\nlet inventory = [\"HP\",  \"MP\"];\nlet currentHP = 20;\nlet maxHP = 100;\nlet currentMP = 50;\nlet maxMP = 100;\nlet showAttack = false; // When you prep an attack, it'll show your attack range\nlet attackBlock = [null,null]; // the attack coords of your character\nlet monstersMove = false; // Tells you when the monsters should move\nlet gameOver = false; \nlet showControls = false;\n// TODO: might have to change to dx, dy in the future when implementing different weapons \n// Drawing Board\nconst canvas = document.getElementById(\"gameCanvas\"); // The actual canvas element\nconst gameCanvas = canvas.getContext(\"2d\"); // The paintbrush to draw everything required for this game\nexport const togglePause = () =>{\n    showControls = !showControls;\n    moveChar(0,0);\n}\n// This is used to move the character. moveChar(0,0) is usually used to re-render the game\nexport const moveChar = (dx, dy) => {\n    window.items = items;\n    if (char[0] < 0){return;} // The character has died\n    // Check to see if character is out of bounds\n    if(char[0] + dx === 0 || char[0] + dx === maxWidth-1){\n        if (char[1] !== (maxHeight - 1) / 2) {return;}\n    }\n    if(char[1] + dy === 0 || char[1] + dy === maxHeight-1){\n        if (char[0] !== (maxWidth - 1) / 2)  {return;}\n    }\n    // Check to see if monster is blocking the characters movement\n    let monsterBlock = false; \n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n            if (monster.x === char[0] + dx && monster.y === char[1] + dy) {\n                monsterBlock = true; // Character is blocked from moving here\n            }\n        })\n    })\n    // If not blocked by monster, continue the action\n    if(!monsterBlock && !showControls){\n        char[0] += dx;\n        char[1] += dy;\n        let movedRoom = false;\n        // Check to see if the player went through a door\n        // TODO: Make sure to only render doors that are valid (right now it's infinite dungeon)\n        if(char[1] === (maxHeight-1)/2){\n            if (char[0] === 0) {\n                char[0] = maxWidth - 2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[0] === maxWidth-1) {\n                char[0] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        } else if(char[0] === (maxWidth-1)/2){\n            if(char[1] === 0){\n                char[1] = maxHeight-2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[1] === maxHeight-1){\n                char[1] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        }\n        // if the player moved (but not to another room) and the monsters are allowed to move\n        // then the monsters will take their turn\n        if ((dx + dy !== 0 || monstersMove) && !movedRoom) {\n            monstersMove = false;\n            Object.values(monsters).forEach(row => {\n                Object.values(row).forEach(monster => {\n                    if (monster.moved) { return; } // if the monster already moved this turn,\n                    const monsterTurn = monster.takeTurn(char[0], char[1]);\n                    if (monsterTurn) { // If this returns true, the monster will be attacking a position\n                        if (monster.attackX === char[0] && monster.attackY === char[1]) {\n                            // If player is in the attack range, lose health\n                            currentHP -= 10;\n                        }\n                        // Attack has completed. Now set it to null\n                        monster.attackX = null;\n                        monster.attackY = null;\n                    } else if (monsterTurn === false) { // Not close enough to attack the player\n                        // Difference between char and monster\n                        const dxMon = char[0] - monster.x;\n                        const dyMon = char[1] - monster.y;\n                        // A step towards the player\n                        const dxMonNorm = Math.abs(dxMon) / dxMon || 0;\n                        const dyMonNorm = Math.abs(dyMon) / dyMon || 0;\n                        // New Pos if they move\n                        const newMonX = monster.x + dxMonNorm;\n                        const newMonY = monster.y + dyMonNorm;\n                        // can move in that direction\n                        let canMoveX = true;\n                        let canMoveY = true;\n                        // Check if monsters are blocking\n                        if (monsters[monster.x][newMonY] !== undefined) {\n                            canMoveY = false;\n                        }\n                        if (monsters[newMonX][monster.y] !== undefined) {\n                            canMoveX = false;\n                        }\n                        // Temporarily save the monster, delete the monster from monsters object\n                        // Then move the monster and save it in the new coords\n                        const tempMon = monster;\n                        delete monsters[monster.x][monster.y]\n                        if (Math.abs(dxMon) > Math.abs(dyMon)) {\n                            if (canMoveY) {\n                                tempMon.y = newMonY;\n                            } else if(canMoveX){\n                                tempMon.x = newMonX;\n                            }\n                        } else {\n                            if (canMoveX) {\n                                tempMon.x = newMonX;\n                            } else if (canMoveY) {\n                                tempMon.y = newMonY;\n                            }\n                        }\n                        tempMon.moved = true;\n                        monsters[tempMon.x][tempMon.y] = tempMon;\n                    }\n                })\n            })\n        }\n        // once all the monsters have moved, we will set it back to false for next turn\n        Object.values(monsters).forEach(row => {\n            Object.values(row).forEach(monster => {\n                monster.moved = false; \n            })\n        })\n        // If currentHP <= 0, we set gameOver to true so we player can't do anything\n        if (currentHP <= 0) {\n            currentHP = 0;\n            char[0] = -1000;\n            char[1] = -1000;\n            gameOver = true;\n        }\n    } else if(showControls){\n        gameCanvas.beginPath();\n        gameCanvas.fillStyle = \"#555\";\n        gameCanvas.rect(50, 50, (maxWidth-2)*cD, (maxHeight-2)*cD);\n        gameCanvas.fill();\n        gameCanvas.font = \"30px Roboto, sans serif\"\n        gameCanvas.fillStyle = \"#FFF\";\n        gameCanvas.fillText(\"Arrow keys = Movement\", 60, 100)\n        gameCanvas.fillText(\"Spacebar = Use Item/Start Attack\", 60, 160)\n        gameCanvas.fillText(\"Z = Inventory\", 60, 220)\n        gameCanvas.fillText(\"Spacebar (After Starting Attack) = Attack/Wait\", 60, 280)\n        gameCanvas.fillText(\"Esc = Show/Hide Controls\", 60, (maxHeight-2)*cD)\n        gameCanvas.closePath()\n        return;\n    } else {return;} // if character is blocked by the monster, don't move here\n    // Drawing Floor, Walls, Items, and Monsters\n    gameCanvas.beginPath();\n    if(showInvCursor || gameOver){\n        gameCanvas.globalAlpha = 0.5;\n    }\n    gameCanvas.clearRect(0, 0, maxWidth * cD, maxHeight * cD);\n    gameCanvas.closePath();\n    for(let i = 1; i < maxWidth-1; i++){\n        for(let j = 1; j < maxHeight-1; j++){\n            //Dungeon Floor\n            gameCanvas.beginPath();\n            gameCanvas.rect(i * cD, j * cD, cD, cD);\n            gameCanvas.fillStyle = floorBGColor;\n            gameCanvas.fill();\n            gameCanvas.drawImage(floorTile, i * cD, j * cD, cD, cD);\n            gameCanvas.closePath();\n        }\n    }\n    gameCanvas.beginPath();\n    // Drawing the walls\n    for (let i = 0; i < maxWidth; i++) {\n        if (i === 0 || i === maxWidth - 1) {\n            for (let j = 0; j <= maxHeight; j++) {\n                if (j === (maxHeight - 1) / 2) {\n                    gameCanvas.drawImage(door, i*cD, j*cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n            continue;\n        }\n        for (let j = 0; j < maxHeight; j++) {\n            if (j === 0 || j === maxHeight - 1) {\n                if (i === (maxWidth - 1) / 2) {\n                    gameCanvas.drawImage(door, i * cD, j * cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n        }\n    }\n    // Drawing Items\n    Object.keys(items).forEach(itemName =>{\n        for(let i = 0; i < items[itemName].length; i++){\n            // If character is standing on the item, push it to their inventory\n            const x = items[itemName][i][0];\n            const y = items[itemName][i][1];\n            if ( x === char[0] && y === char[1]){\n                \n                if(itemName === \"G\"){goldCount++;}\n                else { inventory.push(itemName);}\n\n                items[itemName] = items[itemName].slice(0, i).concat(items[itemName].slice(i + 1, items.length));\n                i--;\n            } else {\n                switch(itemName){\n                    case \"G\":\n                        gameCanvas.drawImage(goldBar, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"HP\":\n                        gameCanvas.drawImage(healthPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"MP\":\n                        gameCanvas.drawImage(manaPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    default:\n                        console.log(`Unknown Item: ${itemName}`)\n                        break;\n                }\n            }\n        }\n    })\n    // for (let i = 0; i < maxWidth; i++) {\n    //     for (let j = 0; j < maxHeight; j++) {\n    //         let renderGold = false;\n    //         let renderHP = false;\n    //         let renderMP = false;\n    //         // render Walls.\n    //         // iterate through items\n    //         // for(let k = 0; k < wC[i][j].length; k++){\n    //         //     switch (wC[i][j][k]) {\n    //         //         case \"w\":\n    //         //             // gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n    //         //             renderWall = true;\n    //         //             break;\n    //         //         case \"d\":\n    //         //             renderDoor = true;\n    //         //             break;\n    //         //         case \"G\":\n    //         //             // gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD);\n    //         //             renderGold = true;\n    //         //             break;\n    //         //         case \"HP\":\n    //         //             // gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD);\n    //         //             renderHP = true;\n    //         //             break;\n    //         //         case \"MP\":\n    //         //             // gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD);\n    //         //             renderMP = true;\n    //         //             break;\n    //         //         default:\n    //         //             break;\n    //         //     }\n    //         // }\n    //         if (renderGold) { gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD); }\n    //         if (renderHP) { gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD); }\n    //         if (renderMP) { gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD); }\n    //     }\n    // }\n    // Render the character\n    renderChar(char[0], char[1]);\n    // Render Monsters\n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n        // const monster = monsters[i][j];\n            gameCanvas.drawImage(monster.monsterIMG, monster.x * cD, monster.y * cD, cD, cD);\n            // If monsters have less health than max health, render it\n            if (monster.currentHP < monster.maxHP) { \n                gameCanvas.fillStyle = \"#FFF\";\n                gameCanvas.rect(monster.x*cD, monster.y*cD, cD, 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n                gameCanvas.fillStyle = \"#F00\";\n                gameCanvas.rect(monster.x * cD, monster.y * cD, cD * (monster.currentHP / monster.maxHP), 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n            }\n            // if monster is attacking, show direction\n            if (monster.attackX !== null) { \n                gameCanvas.globalAlpha = 0.5;\n                gameCanvas.drawImage(monster.monsterATK, monster.attackX * cD, monster.attackY * cD, cD, cD);\n                gameCanvas.globalAlpha = 1;\n            }\n        })\n    })\n    gameCanvas.closePath();\n    if(showAttack === true){ // Show your attack range\n        gameCanvas.beginPath();\n        gameCanvas.globalAlpha = 0.8;\n        gameCanvas.drawImage(sword, attackBlock[0]*cD, attackBlock[1]*cD, cD, cD)\n        gameCanvas.globalAlpha = 1;\n        gameCanvas.closePath();\n    }\n\n    if (showInvCursor || gameOver) {\n        gameCanvas.globalAlpha = 1;\n    }\n    // Inventory UI\n    gameCanvas.beginPath();\n    gameCanvas.rect(maxWidth * cD, 0, 300, (maxHeight*cD));\n    gameCanvas.fillStyle = \"#666666\"\n    gameCanvas.fill();\n    gameCanvas.rect(invXCoord, invYCoord, cD*invWidth, (invHeight * cD))\n    gameCanvas.strokeStyle = \"#FFF\";\n    gameCanvas.stroke();\n    for(let i = 0; i < inventory.length;i++){\n        switch(inventory[i]){\n            case \"HP\":\n                gameCanvas.drawImage(healthPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            case \"MP\":\n                gameCanvas.drawImage(manaPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            default:\n                break;\n        }\n    }\n    gameCanvas.closePath();\n    // HP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current HP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, (cD*5 * currentHP/maxHP), hpHeight);\n    gameCanvas.fillStyle = \"#F00\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // MP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current MP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, (cD*5 * currentMP/maxMP), hpHeight);\n    gameCanvas.fillStyle = \"#00F\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Inventory Cursor\n    if (showInvCursor) {\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#000\";\n        gameCanvas.fillText(\"INVENTORY\", (maxWidth * cD / 2)-cD*4, maxHeight * cD / 2);\n        gameCanvas.rect(invCursorX, invCursorY, cD, cD);\n        gameCanvas.strokeStyle = \"#FFF\";\n        gameCanvas.stroke();\n        gameCanvas.closePath();\n    }\n\n    // Gold Counter\n    gameCanvas.beginPath();\n    gameCanvas.drawImage(goldBar, maxWidth*cD+20, 0, cD, cD);\n    gameCanvas.font = \"15px Roboto, sans serif\";\n    gameCanvas.fillStyle = \"#ffd700\"\n    gameCanvas.fillText(`x ${goldCount}`, maxWidth * 50 + 80, 30, 225);\n    gameCanvas.closePath();\n    if(gameOver){ // If player died\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#ff0000\";\n        gameCanvas.fillText(\"GAME OVER\", (maxWidth * cD / 2) - cD * 4, maxHeight * cD / 2 + 25);\n        gameCanvas.closePath();\n    }\n    return;\n}\n\nexport const toggleInvCursor = bool => {\n    showInvCursor = bool;\n    moveChar(0,0);\n}\n\nexport const moveInvCursor = (dx, dy) => {\n    const newCursorX = invCursorX + dx * cD;\n    const newCursorY = invCursorY + dy * cD;\n    if(newCursorX >= invXCoord && newCursorX < invXCoord + (invWidth * cD)){\n        invCursorX = newCursorX;\n        invCursorPos += dx\n    }\n    if (newCursorY >= invYCoord && newCursorY < invYCoord +(invHeight * cD)) {\n        invCursorY = newCursorY;\n        invCursorPos += (dy*5)\n    }\n    moveChar(0,0);\n}\n\nexport const useItem = () => {\n    if (inventory.length < invCursorPos + 1) {\n        gameCanvas.beginPath();\n        gameCanvas.font = \"10px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Empty Slot\", char[0] * cD, char[1] * cD);\n        gameCanvas.closePath();\n    } else {\n        // Use Item\n        switch (inventory[invCursorPos]) {\n            case \"HP\":\n                currentHP += 25;\n                break;\n            case \"MP\":\n                // Mana\n                currentMP += 50;\n                break;\n            default:\n                break;\n        }\n        if (currentHP > maxHP) {\n            currentHP = maxHP;\n        }\n        if (currentMP > maxMP){\n            currentMP = maxMP;\n        }\n        inventory = inventory.slice(0, invCursorPos).concat(inventory.slice(invCursorPos + 1, inventory.length));\n        moveChar(0,0);\n    }\n}\n\nexport const toggleAttack = (bool=false) =>{\n    showAttack = bool || !showAttack;\n    attackBlock[0] = char[0];\n    attackBlock[1] = char[1]+1;\n    moveChar(0, 0);\n}\n\nexport const attackDir = (dx, dy) => {\n    attackBlock[0] = char[0] + dx;\n    attackBlock[1] = char[1] + dy;\n    moveChar(0,0);\n}\n\nexport const attack = () => {\n    monstersMove = true;\n    try{\n        const newHP = monsters[attackBlock[0]][attackBlock[1]].takeDmg(50);\n        if (newHP <= 0) {\n            delete monsters[attackBlock[0]][attackBlock[1]];\n            const randomNum = rng(100);\n            if(randomNum > 99){\n                items[\"MP\"].push([attackBlock[0], attackBlock[1]]);\n            } else if(randomNum > 60){\n                items[\"HP\"].push([attackBlock[0], attackBlock[1]]);\n            } else {\n                items[\"G\"].push([attackBlock[0], attackBlock[1]]);\n            }\n        }\n        toggleAttack();\n    } catch (err) {\n        console.log(err);\n        toggleAttack();\n        gameCanvas.beginPath();\n        gameCanvas.font = \"8px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Waited a turn\", char[0]*cD, char[1]*cD);\n        gameCanvas.closePath();\n    }\n    \n}\n","import \"./styles/index.scss\";\nimport { maxHeight, maxWidth, moveChar, useItem, moveInvCursor, toggleAttack, attack, attackDir, toggleInvCursor, togglePause } from \"./scripts/game\"; \nimport { cD } from \"./scripts/char\";\n\nlet useInvCursor = false;\nlet showAttack = false;\nlet paused = true;\n\nconst keydownPress = e => {\n    if(e.key === \" \"){e.preventDefault();}\n    let dx = 0;\n    let dy = 0;\n    // Movement\n    if (e.key == \"Right\" || e.key == \"ArrowRight\") {\n        dx += 1;\n    } else if (e.key == \"Left\" || e.key == \"ArrowLeft\") {\n        dx -= 1;\n    } else if (e.key == \"Up\" || e.key == \"ArrowUp\") {\n        e.preventDefault();\n        dy -= 1\n    } else if (e.key == \"Down\" || e.key == \"ArrowDown\") {\n        e.preventDefault();\n        dy += 1\n    }\n    if ((e.key === \"z\" || e.key === \"Z\") && !paused) {\n        // Open Inventory\n        useInvCursor = !useInvCursor;\n        toggleInvCursor(useInvCursor);\n    } else if((e.key === \"x\" || e.key === \"X\") && showAttack && !paused) {\n        // Cancel Attack\n        toggleAttack(false);\n        showAttack = false;\n    } else if(e.key === \"Escape\"){\n        paused = !paused;\n        togglePause();\n    } else if(dx+dy != 0 && !useInvCursor && !showAttack && !paused){\n        // if the character has moved and we're not moving the inventory cursor and we're not attacking\n        moveChar(dx, dy);\n    } else if (dx+dy != 0 && useInvCursor && !paused){ \n        // useInvCursor === true => move the inventory cursor\n        moveInvCursor(dx, dy);\n    } else if (e.key === \" \" && useInvCursor && !paused){ \n        // Use Item in inventory\n        useItem();\n    } else if(dx+dy != 0 && showAttack && !paused){\n        attackDir(dx, dy);\n    } else if (e.key === \" \" && !useInvCursor && !paused){\n        // Attack\n        if(showAttack){\n            attack();\n        } else {\n            toggleAttack(true);\n        }\n        showAttack = !showAttack\n    }\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n    const canvas = document.getElementById(\"gameCanvas\");\n    // canvas.width = window.innerWidth - 10;\n    // canvas.height = window.innerHeight - 20;\n    // Set the width and height of canvas\n    canvas.width = maxWidth * cD + 300;\n    canvas.height = maxHeight * cD;\n    // moveChar renders the character without moving it\n    setTimeout(() => {\n        moveChar(0, 0)\n        togglePause();\n    }, 100)\n    console.log(\"Game Loaded\");\n    // This will allow us to move the character\n    document.addEventListener(\"keydown\", keydownPress, false);\n});\n\n"],"sourceRoot":""}