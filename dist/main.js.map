{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/char.js","webpack:///./src/scripts/monster.js","webpack:///./src/scripts/game.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","playerImg","Image","src","char","document","getElementById","getContext","octopusIMG","octopusATK","Monster","type","x","y","this","currentHP","maxHP","monsterIMG","monsterATK","attackX","attackY","moved","dmg","charX","charY","Math","abs","rng","num","floor","random","goldBar","wall","door","floorBGColor","healthPotion","manaPotion","sword","showInvCursor","invCursorX","maxWidth","invCursorY","invCursorPos","items","monsters","newRoom","monsterNum","log","maxHeight","goldCount","inventory","currentMP","showAttack","attackBlock","monstersMove","gameOver","showControls","gameCanvas","togglePause","moveChar","dx","dy","window","monsterBlock","values","forEach","row","monster","beginPath","fillStyle","rect","fill","font","fillText","closePath","newX","newY","movedRoom","monsterTurn","takeTurn","dxMon","dyMon","dxMonNorm","dyMonNorm","newMonX","newMonY","canMoveX","canMoveY","undefined","tempMon","globalAlpha","clearRect","j","drawImage","keys","itemName","length","push","slice","concat","console","cD","invHeight","strokeStyle","stroke","hpYCoord","toggleAttack","bool","useInvCursor","paused","canvas","width","height","setTimeout","addEventListener","e","preventDefault","newCursorX","newCursorY","invXCoord","invYCoord","moveInvCursor","useItem","attackDir","takeDmg","randomNum","err","attack"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import {floorBGColor} from \"./game\";\n\n\nvar playerImg = new Image();\nplayerImg.src = \"https://image.flaticon.com/icons/svg/2328/2328493.svg\";\n\nexport let cD = 50; // character dimension\n// Players starting position\nexport const startX = 9;\nexport const startY = 5;\n\nlet x = cD * startX;\nlet y = cD * startY;\n\n\nconst canvas = document.getElementById(\"gameCanvas\");\nconst char = canvas.getContext(\"2d\");\n\nexport function renderChar(newX, newY) {\n    char.beginPath();\n    char.fillStyle = floorBGColor;\n    // char.rect(x * cD, y * cD, cD, cD);\n    // char.rect(newX * cD, newY * cD, cD, cD);\n    char.fill();\n    char.drawImage(playerImg, newX * cD, newY * cD, cD, cD);\n\n\n    x = newX;\n    y = newY;\n    char.closePath(); \n}","\nvar octopusIMG = new Image();\noctopusIMG.src = \"https://image.flaticon.com/icons/svg/2196/2196893.svg\";\n\nvar octopusATK = new Image();\noctopusATK.src = \"https://image.flaticon.com/icons/svg/651/651510.svg\";\n\nexport class Monster{\n    constructor(type, x, y){\n        switch(type){\n            case \"o\":\n                this.name = \"Octopus\";\n                this.currentHP = 100;\n                this.maxHP = 100;\n                this.monsterIMG = octopusIMG;\n                this.monsterATK = octopusATK;\n                break;\n            case \"v\":\n                this.name = \"Vampire\";\n                this.currentHP = 200;\n                this.maxHP = 200;\n            default:\n                this.name = \"Unknown\";\n                this.currentHP = 1;\n                this.maxHP = 1;\n        }\n        this.x = x;\n        this.y = y;\n        this.attackX = null;\n        this.attackY = null;\n        this.moved = false;\n    }\n\n    takeDmg(dmg){\n        this.currentHP -= dmg;\n        return this.currentHP;\n    }\n\n    takeTurn(charX, charY){\n        if(this.attackX !== null){\n            // Attacking the character this turn\n            return true // return true for attacking\n        } else {\n            if ((charX === this.x && Math.abs(charY-this.y) === 1) || (charY === this.y && Math.abs(charX - this.x) === 1)){\n                this.attackX = charX;\n                this.attackY = charY;\n                return null;\n            }\n            //Move the monster towards the player\n            return false // return false for not attacking\n        }\n        \n    }\n}\n","import { cD, renderChar, startX, startY } from \"./char\";\nimport { Monster} from \"./monster\";\n\n// Random Number Generator\nconst rng = (num) => Math.floor(Math.random() * num)+1;\n//Images\nvar goldBar = new Image();\ngoldBar.src = \"https://image.flaticon.com/icons/svg/362/362944.svg\";\n\nvar wall = new Image();\nwall.src = \"https://image.flaticon.com/icons/svg/351/351764.svg\";\n\nvar door = new Image();\ndoor.src = \"https://www.flaticon.com/premium-icon/icons/svg/2401/2401054.svg\";\n\nexport const floorBGColor = \"#999\";\n\nvar healthPotion = new Image();\nhealthPotion.src = \"https://image.flaticon.com/icons/svg/506/506927.svg\";\n\nvar manaPotion = new Image();\nmanaPotion.src = \"https://image.flaticon.com/icons/svg/1006/1006951.svg\";\n\nvar sword = new Image();\nsword.src = \"https://image.flaticon.com/icons/svg/361/361806.svg\";\n// width and height of dungeons\nexport const maxWidth = 19;\nexport const maxHeight = 11;\n// Inventory Coords\nconst invXCoord = maxWidth * cD + 22;\nconst invYCoord = 90;\nconst invWidth = 5;\nconst invHeight = 5;\n// Inventory Cursor\nlet showInvCursor = false;\nlet invCursorX = maxWidth * cD + 22;\nlet invCursorY = 90;\nlet invCursorPos = 0;\n// Char Pos\nconst char = [startX, startY];\n// HP Bar\nconst hpXCoord = maxWidth * cD + 22;\nconst hpYCoord = 45;\nconst hpHeight = 15\n// TODO: Implement rooms object when ready\n// let rooms = {}; // 9 * 9 room. player starts in [5][5]\n// for(let i = 0; i < 10; i++){\n//      rooms[i] = {};\n// }\n// let currentRoom = [5,5];\n// Items in the room\nlet items = {};\nlet monsters = {};\n\nconst newRoom = () => { // Generate a new room\n    monsters = {};\n    items = {\n        \"G\":[],\n        \"HP\":[],\n        \"MP\":[]\n    };\n    for (let i = 1; i < maxWidth-1; i++) {\n        monsters[i] = {};\n    }\n    // Monster generator\n    // let monsterNum = Math.floor((rng(100)-(100-monsterLimit*10)+9)/10);\n    let monsterNum = Math.floor(Math.log(rng(34)-10));\n    for(let i = 0; i < monsterNum; i++){\n        let x = char[0];\n        let y = char[1];\n        while(char[0] === x && char[1] === y) {\n            x = rng(maxWidth - 2);\n            y = rng(maxHeight - 2);\n        }\n        monsters[x][y] = new Monster(\"o\", x, y)\n    }\n}\nnewRoom(); // Generate the room in the beginning of the game\nitems = { // Initial Room has items for player\n    \"G\": [[1, 1], [1, 2]],\n    \"HP\": [[2, 2], [2, 3]],\n    \"MP\": [],\n};\n// Some Health Potions\nlet goldCount = 0;\nlet inventory = [\"HP\",  \"MP\"];\nlet currentHP = 20;\nlet maxHP = 100;\nlet currentMP = 50;\nlet maxMP = 100;\nlet showAttack = false; // When you prep an attack, it'll show your attack range\nlet attackBlock = [null,null]; // the attack coords of your character\nlet monstersMove = false; // Tells you when the monsters should move\nlet gameOver = false; \nlet showControls = false;\n// TODO: might have to change to dx, dy in the future when implementing different weapons \n// Drawing Board\nconst canvas = document.getElementById(\"gameCanvas\"); // The actual canvas element\nconst gameCanvas = canvas.getContext(\"2d\"); // The paintbrush to draw everything required for this game\nexport const togglePause = () =>{\n    showControls = !showControls;\n    moveChar(0,0);\n}\n// This is used to move the character. moveChar(0,0) is usually used to re-render the game\nexport const moveChar = (dx, dy) => {\n    window.items = items;\n    if (char[0] < 0){return;} // The character has died\n    // Check to see if character is out of bounds\n    if(char[0] + dx === 0 || char[0] + dx === maxWidth-1){\n        if (char[1] !== (maxHeight - 1) / 2) {return;}\n    }\n    if(char[1] + dy === 0 || char[1] + dy === maxHeight-1){\n        if (char[0] !== (maxWidth - 1) / 2)  {return;}\n    }\n    // Check to see if monster is blocking the characters movement\n    let monsterBlock = false; \n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n            if (monster.x === char[0] + dx && monster.y === char[1] + dy) {\n                monsterBlock = true; // Character is blocked from moving here\n            }\n        })\n    })\n    // If not blocked by monster, continue the action\n    if(!monsterBlock && !showControls){\n        char[0] += dx;\n        char[1] += dy;\n        let movedRoom = false;\n        // Check to see if the player went through a door\n        // TODO: Make sure to only render doors that are valid (right now it's infinite dungeon)\n        if(char[1] === (maxHeight-1)/2){\n            if (char[0] === 0) {\n                char[0] = maxWidth - 2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[0] === maxWidth-1) {\n                char[0] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        } else if(char[0] === (maxWidth-1)/2){\n            if(char[1] === 0){\n                char[1] = maxHeight-2;\n                newRoom();\n                movedRoom = true;\n            } else if (char[1] === maxHeight-1){\n                char[1] = 1;\n                newRoom();\n                movedRoom = true;\n            }\n        }\n        // if the player moved (but not to another room) and the monsters are allowed to move\n        // then the monsters will take their turn\n        if ((dx + dy !== 0 || monstersMove) && !movedRoom) {\n            monstersMove = false;\n            Object.values(monsters).forEach(row => {\n                Object.values(row).forEach(monster => {\n                    if (monster.moved) { return; } // if the monster already moved this turn,\n                    const monsterTurn = monster.takeTurn(char[0], char[1]);\n                    if (monsterTurn) { // If this returns true, the monster will be attacking a position\n                        if (monster.attackX === char[0] && monster.attackY === char[1]) {\n                            // If player is in the attack range, lose health\n                            currentHP -= 10;\n                        }\n                        // Attack has completed. Now set it to null\n                        monster.attackX = null;\n                        monster.attackY = null;\n                    } else if (monsterTurn === false) { // Not close enough to attack the player\n                        // Difference between char and monster\n                        const dxMon = char[0] - monster.x;\n                        const dyMon = char[1] - monster.y;\n                        // A step towards the player\n                        const dxMonNorm = Math.abs(dxMon) / dxMon || 0;\n                        const dyMonNorm = Math.abs(dyMon) / dyMon || 0;\n                        // New Pos if they move\n                        const newMonX = monster.x + dxMonNorm;\n                        const newMonY = monster.y + dyMonNorm;\n                        // can move in that direction\n                        let canMoveX = true;\n                        let canMoveY = true;\n                        // Check if monsters are blocking\n                        if (monsters[monster.x][newMonY] !== undefined) {\n                            canMoveY = false;\n                        }\n                        if (monsters[newMonX][monster.y] !== undefined) {\n                            canMoveX = false;\n                        }\n                        // Temporarily save the monster, delete the monster from monsters object\n                        // Then move the monster and save it in the new coords\n                        const tempMon = monster;\n                        delete monsters[monster.x][monster.y]\n                        if (rng(100) < 50) {\n                            if (canMoveY) {\n                                tempMon.y = newMonY;\n                            } else if(canMoveX){\n                                tempMon.x = newMonX;\n                            }\n                        } else {\n                            if (canMoveX) {\n                                tempMon.x = newMonX;\n                            } else if (canMoveY) {\n                                tempMon.y = newMonY;\n                            }\n                        }\n                        tempMon.moved = true;\n                        monsters[tempMon.x][tempMon.y] = tempMon;\n                    }\n                })\n            })\n        }\n        // once all the monsters have moved, we will set it back to false for next turn\n        Object.values(monsters).forEach(row => {\n            Object.values(row).forEach(monster => {\n                monster.moved = false; \n            })\n        })\n        // If currentHP <= 0, we set gameOver to true so we player can't do anything\n        if (currentHP <= 0) {\n            currentHP = 0;\n            char[0] = -1000;\n            char[1] = -1000;\n            gameOver = true;\n        }\n    } else if(showControls){\n        gameCanvas.beginPath();\n        gameCanvas.fillStyle = \"#555\";\n        gameCanvas.rect(50, 50, (maxWidth-2)*cD, (maxHeight-2)*cD);\n        gameCanvas.fill();\n        gameCanvas.font = \"30px Roboto, sans serif\"\n        gameCanvas.fillStyle = \"#FFF\";\n        gameCanvas.fillText(\"Arrow keys = Movement\", 60, 100)\n        gameCanvas.fillText(\"Spacebar = Use Item/Start Attack\", 60, 160)\n        gameCanvas.fillText(\"Z = Inventory\", 60, 220)\n        gameCanvas.fillText(\"Spacebar (After Starting Attack) = Attack/Wait\", 60, 280)\n        gameCanvas.fillText(\"Esc = Show/Hide Controls\", 60, (maxHeight-2)*cD)\n        gameCanvas.closePath()\n        return;\n    } else {return;} // if character is blocked by the monster, don't move here\n    // Drawing Floor, Walls, Items, and Monsters\n    gameCanvas.beginPath();\n    if(showInvCursor || gameOver){\n        gameCanvas.globalAlpha = 0.5;\n    }\n    gameCanvas.clearRect(0, 0, maxWidth * cD, maxHeight * cD);\n    gameCanvas.closePath();\n    for(let i = 1; i < maxWidth-1; i++){\n        for(let j = 1; j < maxHeight-1; j++){\n            //Dungeon Floor\n            gameCanvas.beginPath();\n            gameCanvas.rect(i * cD, j * cD, cD, cD);\n            gameCanvas.fillStyle = floorBGColor;\n            gameCanvas.fill();\n            gameCanvas.closePath();\n        }\n    }\n    gameCanvas.beginPath();\n    // Drawing the walls\n    for (let i = 0; i < maxWidth; i++) {\n        if (i === 0 || i === maxWidth - 1) {\n            for (let j = 0; j <= maxHeight; j++) {\n                if (j === (maxHeight - 1) / 2) {\n                    gameCanvas.drawImage(door, i*cD, j*cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n            continue;\n        }\n        for (let j = 0; j < maxHeight; j++) {\n            if (j === 0 || j === maxHeight - 1) {\n                if (i === (maxWidth - 1) / 2) {\n                    gameCanvas.drawImage(door, i * cD, j * cD, cD, cD);\n                } else {\n                    gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n                }\n            }\n        }\n    }\n    // Drawing Items\n    Object.keys(items).forEach(itemName =>{\n        for(let i = 0; i < items[itemName].length; i++){\n            // If character is standing on the item, push it to their inventory\n            const x = items[itemName][i][0];\n            const y = items[itemName][i][1];\n            if ( x === char[0] && y === char[1]){\n                \n                if(itemName === \"G\"){goldCount++;}\n                else { inventory.push(itemName);}\n\n                items[itemName] = items[itemName].slice(0, i).concat(items[itemName].slice(i + 1, items.length));\n                i--;\n            } else {\n                switch(itemName){\n                    case \"G\":\n                        gameCanvas.drawImage(goldBar, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"HP\":\n                        gameCanvas.drawImage(healthPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    case \"MP\":\n                        gameCanvas.drawImage(manaPotion, x * cD, y * cD, cD, cD);\n                        break;\n                    default:\n                        console.log(`Unknown Item: ${itemName}`)\n                        break;\n                }\n            }\n        }\n    })\n    // for (let i = 0; i < maxWidth; i++) {\n    //     for (let j = 0; j < maxHeight; j++) {\n    //         let renderGold = false;\n    //         let renderHP = false;\n    //         let renderMP = false;\n    //         // render Walls.\n    //         // iterate through items\n    //         // for(let k = 0; k < wC[i][j].length; k++){\n    //         //     switch (wC[i][j][k]) {\n    //         //         case \"w\":\n    //         //             // gameCanvas.drawImage(wall, i * cD, j * cD, cD, cD);\n    //         //             renderWall = true;\n    //         //             break;\n    //         //         case \"d\":\n    //         //             renderDoor = true;\n    //         //             break;\n    //         //         case \"G\":\n    //         //             // gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD);\n    //         //             renderGold = true;\n    //         //             break;\n    //         //         case \"HP\":\n    //         //             // gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD);\n    //         //             renderHP = true;\n    //         //             break;\n    //         //         case \"MP\":\n    //         //             // gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD);\n    //         //             renderMP = true;\n    //         //             break;\n    //         //         default:\n    //         //             break;\n    //         //     }\n    //         // }\n    //         if (renderGold) { gameCanvas.drawImage(goldBar, i * cD, j * cD, cD, cD); }\n    //         if (renderHP) { gameCanvas.drawImage(healthPotion, i * cD, j * cD, cD, cD); }\n    //         if (renderMP) { gameCanvas.drawImage(manaPotion, i * cD, j * cD, cD, cD); }\n    //     }\n    // }\n    // Render the character\n    renderChar(char[0], char[1]);\n    // Render Monsters\n    Object.values(monsters).forEach(row => {\n        Object.values(row).forEach(monster => {\n        // const monster = monsters[i][j];\n            gameCanvas.drawImage(monster.monsterIMG, monster.x * cD, monster.y * cD, cD, cD);\n            // If monsters have less health than max health, render it\n            if (monster.currentHP < monster.maxHP) { \n                gameCanvas.fillStyle = \"#FFF\";\n                gameCanvas.rect(monster.x*cD, monster.y*cD, cD, 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n                gameCanvas.fillStyle = \"#F00\";\n                gameCanvas.rect(monster.x * cD, monster.y * cD, cD * (monster.currentHP / monster.maxHP), 10);\n                gameCanvas.fill();\n                gameCanvas.closePath();\n                gameCanvas.beginPath();\n            }\n            // if monster is attacking, show direction\n            if (monster.attackX !== null) { \n                gameCanvas.globalAlpha = 0.5;\n                gameCanvas.drawImage(monster.monsterATK, monster.attackX * cD, monster.attackY * cD, cD, cD);\n                gameCanvas.globalAlpha = 1;\n            }\n        })\n    })\n    gameCanvas.closePath();\n    if(showAttack === true){ // Show your attack range\n        gameCanvas.beginPath();\n        gameCanvas.globalAlpha = 0.8;\n        gameCanvas.drawImage(sword, attackBlock[0]*cD, attackBlock[1]*cD, cD, cD)\n        gameCanvas.globalAlpha = 1;\n        gameCanvas.closePath();\n    }\n\n    if (showInvCursor || gameOver) {\n        gameCanvas.globalAlpha = 1;\n    }\n    // Inventory UI\n    gameCanvas.beginPath();\n    gameCanvas.rect(maxWidth * cD, 0, 300, (maxHeight*cD));\n    gameCanvas.fillStyle = \"#666666\"\n    gameCanvas.fill();\n    gameCanvas.rect(invXCoord, invYCoord, cD*invWidth, (invHeight * cD))\n    gameCanvas.strokeStyle = \"#FFF\";\n    gameCanvas.stroke();\n    for(let i = 0; i < inventory.length;i++){\n        switch(inventory[i]){\n            case \"HP\":\n                gameCanvas.drawImage(healthPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            case \"MP\":\n                gameCanvas.drawImage(manaPotion, (i%invWidth)*cD + invXCoord, Math.floor(i/invWidth)*cD + invYCoord, cD, cD)\n                break;\n            default:\n                break;\n        }\n    }\n    gameCanvas.closePath();\n    // HP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current HP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord, (cD*5 * currentHP/maxHP), hpHeight);\n    gameCanvas.fillStyle = \"#F00\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // MP Bar\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, cD*5, hpHeight);\n    gameCanvas.fillStyle = \"#FFF\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Current MP\n    gameCanvas.beginPath();\n    gameCanvas.rect(hpXCoord, hpYCoord+hpHeight, (cD*5 * currentMP/maxMP), hpHeight);\n    gameCanvas.fillStyle = \"#00F\";\n    gameCanvas.fill();\n    gameCanvas.closePath();\n    // Inventory Cursor\n    if (showInvCursor) {\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#000\";\n        gameCanvas.fillText(\"INVENTORY\", (maxWidth * cD / 2)-cD*4, maxHeight * cD / 2);\n        gameCanvas.rect(invCursorX, invCursorY, cD, cD);\n        gameCanvas.strokeStyle = \"#FFF\";\n        gameCanvas.stroke();\n        gameCanvas.closePath();\n    }\n\n    // Gold Counter\n    gameCanvas.beginPath();\n    gameCanvas.drawImage(goldBar, maxWidth*cD+20, 0, cD, cD);\n    gameCanvas.font = \"15px Roboto, sans serif\";\n    gameCanvas.fillStyle = \"#ffd700\"\n    gameCanvas.fillText(`x ${goldCount}`, maxWidth * 50 + 80, 30, 225);\n    gameCanvas.closePath();\n    if(gameOver){ // If player died\n        gameCanvas.beginPath();\n        gameCanvas.font = `${cD}px Roboto, sans serif`;\n        gameCanvas.fillStyle = \"#ff0000\";\n        gameCanvas.fillText(\"GAME OVER\", (maxWidth * cD / 2) - cD * 4, maxHeight * cD / 2 + 25);\n        gameCanvas.closePath();\n    }\n    return;\n}\n\nexport const toggleInvCursor = bool => {\n    showInvCursor = bool;\n    moveChar(0,0);\n}\n\nexport const moveInvCursor = (dx, dy) => {\n    const newCursorX = invCursorX + dx * cD;\n    const newCursorY = invCursorY + dy * cD;\n    if(newCursorX >= invXCoord && newCursorX < invXCoord + (invWidth * cD)){\n        invCursorX = newCursorX;\n        invCursorPos += dx\n    }\n    if (newCursorY >= invYCoord && newCursorY < invYCoord +(invHeight * cD)) {\n        invCursorY = newCursorY;\n        invCursorPos += (dy*5)\n    }\n    moveChar(0,0);\n}\n\nexport const useItem = () => {\n    if (inventory.length < invCursorPos + 1) {\n        gameCanvas.beginPath();\n        gameCanvas.font = \"10px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Empty Slot\", char[0] * cD, char[1] * cD);\n        gameCanvas.closePath();\n    } else {\n        // Use Item\n        switch (inventory[invCursorPos]) {\n            case \"HP\":\n                currentHP += 25;\n                break;\n            case \"MP\":\n                // Mana\n                currentMP += 50;\n                break;\n            default:\n                break;\n        }\n        if (currentHP > maxHP) {\n            currentHP = maxHP;\n        }\n        if (currentMP > maxMP){\n            currentMP = maxMP;\n        }\n        inventory = inventory.slice(0, invCursorPos).concat(inventory.slice(invCursorPos + 1, inventory.length));\n        moveChar(0,0);\n    }\n}\n\nexport const toggleAttack = (bool=false) =>{\n    showAttack = bool || !showAttack;\n    attackBlock[0] = char[0];\n    attackBlock[1] = char[1]+1;\n    moveChar(0, 0);\n}\n\nexport const attackDir = (dx, dy) => {\n    attackBlock[0] = char[0] + dx;\n    attackBlock[1] = char[1] + dy;\n    moveChar(0,0);\n}\n\nexport const attack = () => {\n    monstersMove = true;\n    try{\n        const newHP = monsters[attackBlock[0]][attackBlock[1]].takeDmg(50);\n        if (newHP <= 0) {\n            delete monsters[attackBlock[0]][attackBlock[1]];\n            const randomNum = rng(100);\n            if(randomNum > 99){\n                items[\"MP\"].push([attackBlock[0], attackBlock[1]]);\n            } else if(randomNum > 60){\n                items[\"HP\"].push([attackBlock[0], attackBlock[1]]);\n            } else {\n                items[\"G\"].push([attackBlock[0], attackBlock[1]]);\n            }\n        }\n        toggleAttack();\n    } catch (err) {\n        console.log(err);\n        toggleAttack();\n        gameCanvas.beginPath();\n        gameCanvas.font = \"8px Roboto, sans serif\";\n        gameCanvas.fillStyle = \"red\";\n        gameCanvas.fillText(\"Waited a turn\", char[0]*cD, char[1]*cD);\n        gameCanvas.closePath();\n    }\n    \n}\n","import \"./styles/index.scss\";\nimport { maxHeight, maxWidth, moveChar, useItem, moveInvCursor, toggleAttack, attack, attackDir, toggleInvCursor, togglePause } from \"./scripts/game\"; \nimport { cD } from \"./scripts/char\";\n\nlet useInvCursor = false;\nlet showAttack = false;\nlet paused = true;\n\nconst keydownPress = e => {\n    if(e.key === \" \"){e.preventDefault();}\n    let dx = 0;\n    let dy = 0;\n    // Movement\n    if (e.key == \"Right\" || e.key == \"ArrowRight\") {\n        dx += 1;\n    } else if (e.key == \"Left\" || e.key == \"ArrowLeft\") {\n        dx -= 1;\n    } else if (e.key == \"Up\" || e.key == \"ArrowUp\") {\n        e.preventDefault();\n        dy -= 1\n    } else if (e.key == \"Down\" || e.key == \"ArrowDown\") {\n        e.preventDefault();\n        dy += 1\n    }\n    if ((e.key === \"z\" || e.key === \"Z\") && !paused) {\n        // Open Inventory\n        useInvCursor = !useInvCursor;\n        toggleInvCursor(useInvCursor);\n    } else if((e.key === \"x\" || e.key === \"X\") && showAttack && !paused) {\n        // Cancel Attack\n        toggleAttack(false);\n        showAttack = false;\n    } else if(e.key === \"Escape\"){\n        paused = !paused;\n        togglePause();\n    } else if(dx+dy != 0 && !useInvCursor && !showAttack && !paused){\n        // if the character has moved and we're not moving the inventory cursor and we're not attacking\n        moveChar(dx, dy);\n    } else if (dx+dy != 0 && useInvCursor && !paused){ \n        // useInvCursor === true => move the inventory cursor\n        moveInvCursor(dx, dy);\n    } else if (e.key === \" \" && useInvCursor && !paused){ \n        // Use Item in inventory\n        useItem();\n    } else if(dx+dy != 0 && showAttack && !paused){\n        attackDir(dx, dy);\n    } else if (e.key === \" \" && !useInvCursor && !paused){\n        // Attack\n        if(showAttack){\n            attack();\n        } else {\n            toggleAttack(true);\n        }\n        showAttack = !showAttack\n    }\n}\n\nconst canvas = document.getElementById(\"gameCanvas\");\n// canvas.width = window.innerWidth - 10;\n// canvas.height = window.innerHeight - 20;\n// Set the width and height of canvas\ncanvas.width = maxWidth * cD + 300;\ncanvas.height = maxHeight * cD;\n// moveChar renders the character without moving it\nsetTimeout(() => {\n    moveChar(0, 0)\n    togglePause();\n}, 100)\nconsole.log(\"Game Loaded\");\n// This will allow us to move the character\ndocument.addEventListener(\"keydown\", keydownPress, false);\n"],"sourceRoot":""}